#!/usr/bin/env bash
set -uo pipefail
# shellcheck disable=SC2034,SC2329,SC1091

# Instalador & Exportador de Dotfiles
# Uso bÃ¡sico:
#   bash config/install.sh           # instala
#   bash config/install.sh export    # exporta
#   bash config/install.sh sync      # exporta + instala
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CONFIG_SHARED="$SCRIPT_DIR/shared"
CONFIG_LINUX="$SCRIPT_DIR/linux"
CONFIG_MACOS="$SCRIPT_DIR/macos"
CONFIG_WINDOWS="$SCRIPT_DIR/windows"
CONFIG_FONTS="$SCRIPT_DIR/fonts"
CONFIG_UNIX_LEGACY="$SCRIPT_DIR/mac-linux"
DATA_APPS="$SCRIPT_DIR/data/apps.sh"
DATA_RUNTIMES="$SCRIPT_DIR/data/runtimes.sh"
BACKUP_DIR="$HOME/.dotfiles-backup-$(date +%Y%m%d-%H%M%S)"
TARGET_OS=""
LINUX_PKG_MANAGER=""
LINUX_PKG_UPDATED=0
MODE="install"  # install, export, or sync
FAIL_FAST=1
NO_UPDATES="${NO_UPDATES:-0}"
DRY_RUN="${DRY_RUN:-0}"
INSTALL_ZSH="${INSTALL_ZSH:-1}"
INSTALL_FISH="${INSTALL_FISH:-1}"
INSTALL_ATUIN="${INSTALL_ATUIN:-1}"
INSTALL_SPEC_KIT="${INSTALL_SPEC_KIT:-1}"

declare -a CRITICAL_ERRORS=()
declare -a OPTIONAL_ERRORS=()
declare -a COPIED_PATHS=()
declare -a INSTALLED_PACKAGES=()
declare -a INSTALLED_MISC=()

# Parse argumentos da linha de comando
for arg in "$@"; do
  case "$arg" in
    install|export|sync|help|--help|-h)
      MODE="$arg"
      ;;
    *)
      echo "âŒ Argumento desconhecido: $arg" >&2
      echo "Uso: bash install.sh [install|export|sync]" >&2
      exit 1
      ;;
  esac
done

msg() {
  printf '%s\n' "$1"
}

warn() {
  msg "  âš ï¸ $1"
}

is_truthy() {
  case "${1:-}" in
    1|true|TRUE|yes|YES|y|Y|on|ON) return 0 ;;
    *) return 1 ;;
  esac
}

should_ensure_latest() {
  # Flag principal: NO_UPDATES=1 desativa updates e roda apenas installs ausentes.
  if is_truthy "${NO_UPDATES:-0}"; then
    return 1
  fi

  # Compatibilidade: ENSURE_LATEST=0/1 (nome antigo)
  if [[ -n "${ENSURE_LATEST-}" ]]; then
    is_truthy "${ENSURE_LATEST}"
    return
  fi

  # PadrÃ£o: atualizar itens selecionados quando possÃ­vel
  return 0
}

snap_install_or_refresh() {
  local pkg="$1"
  local friendly="$2"
  local level="${3:-optional}"
  shift 3 || true
  local install_args=("$@")

  has_cmd snap || return 0

  if has_snap_pkg "$pkg"; then
    if should_ensure_latest; then
      msg "  ðŸ”„ Atualizando $friendly via snap..."
      if run_with_sudo snap refresh "$pkg" >/dev/null 2>&1; then
        INSTALLED_MISC+=("$friendly: snap refresh")
      else
        record_failure "$level" "Falha ao atualizar via snap: $friendly ($pkg)"
      fi
    fi
    return 0
  fi

  msg "  ðŸ“¦ Instalando $friendly via snap..."
  if run_with_sudo snap install "${install_args[@]}" "$pkg" >/dev/null 2>&1; then
    INSTALLED_MISC+=("$friendly: snap install")
  else
    record_failure "$level" "Falha ao instalar via snap: $friendly ($pkg)"
  fi
}

ensure_snap_app() {
  # Instala/atualiza via Snap, mas evita duplicar se jÃ¡ houver Flatpak ou binÃ¡rio.
  local pkg="$1"
  local friendly="$2"
  local flatpak_ref="${3:-}"
  local cmd="${4:-}"
  local level="${5:-optional}"

  has_cmd snap || return 0

  if [[ -n "$flatpak_ref" ]] && has_flatpak_ref "$flatpak_ref"; then
    msg "  â„¹ï¸  $friendly jÃ¡ instalado via Flatpak ($flatpak_ref); pulando Snap."
    return 0
  fi

  if [[ -n "$cmd" ]] && has_cmd "$cmd"; then
    msg "  â„¹ï¸  $friendly jÃ¡ estÃ¡ disponÃ­vel no sistema ($cmd); pulando Snap."
    return 0
  fi

  snap_install_or_refresh "$pkg" "$friendly" "$level"
}

flatpak_install_or_update() {
  local ref="$1"
  local friendly="$2"
  local level="${3:-optional}"

  has_cmd flatpak || return 0
  # Garantir flathub (idempotente)
  flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo >/dev/null 2>&1 || true

  if flatpak info "$ref" >/dev/null 2>&1; then
    if should_ensure_latest; then
      msg "  ðŸ”„ Atualizando $friendly via flatpak..."
      if flatpak update -y "$ref" >/dev/null 2>&1; then
        INSTALLED_MISC+=("$friendly: flatpak update")
      else
        record_failure "$level" "Falha ao atualizar via flatpak: $friendly ($ref)"
      fi
    fi
    return 0
  fi

  msg "  ðŸ“¦ Instalando $friendly via flatpak..."
  if flatpak install -y flathub "$ref" >/dev/null 2>&1; then
    INSTALLED_MISC+=("$friendly: flatpak install")
  else
    record_failure "$level" "Falha ao instalar via flatpak: $friendly ($ref)"
  fi
}

ensure_flatpak_app() {
  # Usa Flatpak sÃ³ quando o app nÃ£o estÃ¡ presente via snap/cli; atualiza se jÃ¡ for Flatpak.
  local ref="$1"
  local friendly="$2"
  local snap_pkg="${3:-}"
  local cmd="${4:-}"
  local level="${5:-optional}"

  has_cmd flatpak || return 0

  if has_flatpak_ref "$ref"; then
    flatpak_install_or_update "$ref" "$friendly" "$level"
    return
  fi

  if [[ -n "$snap_pkg" ]] && has_snap_pkg "$snap_pkg"; then
    msg "  â„¹ï¸  $friendly jÃ¡ instalado via snap ($snap_pkg); pulando Flatpak."
    return
  fi

  if [[ -n "$cmd" ]] && has_cmd "$cmd"; then
    msg "  â„¹ï¸  $friendly jÃ¡ estÃ¡ disponÃ­vel no sistema ($cmd); pulando Flatpak."
    return
  fi

  flatpak_install_or_update "$ref" "$friendly" "$level"
}

record_failure() {
  local level="$1"
  local message="$2"
  if [[ "$level" == "critical" ]]; then
    CRITICAL_ERRORS+=("$message")
    warn "âŒ $message"
    if [[ "$FAIL_FAST" -eq 1 ]]; then
      print_final_summary 1
    fi
  else
    OPTIONAL_ERRORS+=("$message")
    warn "$message"
  fi
}

has_cmd() {
  command -v "$1" >/dev/null 2>&1
}

has_snap_pkg() {
  has_cmd snap || return 1
  snap list "$1" >/dev/null 2>&1
}

has_flatpak_ref() {
  has_cmd flatpak || return 1
  flatpak list | grep -q "$1"
}

run_with_sudo() {
  if is_truthy "$DRY_RUN"; then
    msg "  ðŸ”Ž (dry-run) sudo $*"
    return 0
  fi
  if [[ $EUID -eq 0 ]]; then
    "$@"
  elif has_cmd sudo; then
    sudo "$@"
  else
    warn "Comando '$*' requer sudo, mas sudo nÃ£o estÃ¡ disponÃ­vel."
    return 1
  fi
}

backup_if_exists() {
  local path="$1"
  if [[ -e "$path" ]] && [[ "$MODE" == "install" ]]; then
    local base_name=""
    base_name="$(basename "$path")"
    local backup_path="$BACKUP_DIR/$base_name"
    mkdir -p "$BACKUP_DIR"
    msg "  ðŸ’¾ Backup: $path -> $backup_path"
    cp -a "$path" "$backup_path" 2>/dev/null || cp -R "$path" "$backup_path" 2>/dev/null || true
  fi
}

copy_dir() {
  local src="$1"
  local dest="$2"
  [[ -d "$src" ]] || return
  msg "  ðŸ“ $src -> $dest"
  backup_if_exists "$dest"
  mkdir -p "$dest"
  if ! cp -R "$src/." "$dest/"; then
    record_failure "critical" "Falha ao copiar diretÃ³rio: $src -> $dest"
  elif [[ ! -d "$dest" ]]; then
    record_failure "critical" "Destino ausente apÃ³s copiar diretÃ³rio: $dest"
  else
    COPIED_PATHS+=("$dest")
  fi
}

copy_file() {
  local src="$1"
  local dest="$2"
  [[ -f "$src" ]] || return
  msg "  ðŸ“„ $src -> $dest"
  backup_if_exists "$dest"
  mkdir -p "$(dirname "$dest")"
  if is_truthy "$DRY_RUN"; then
    msg "  ðŸ”Ž (dry-run) cp $src $dest"
    return
  fi
  if ! cp "$src" "$dest"; then
    record_failure "critical" "Falha ao copiar arquivo: $src -> $dest"
  elif [[ ! -f "$dest" ]]; then
    record_failure "critical" "Destino ausente apÃ³s copiar arquivo: $dest"
  else
    COPIED_PATHS+=("$dest")
  fi
}

export_dir() {
  local src="$1"
  local dest="$2"
  [[ -d "$src" ]] || return
  msg "  ðŸ“¤ $src -> $dest"
  mkdir -p "$dest"
  if is_truthy "$DRY_RUN"; then
    msg "  ðŸ”Ž (dry-run) cp -R $src/. $dest/"
    return
  fi
  cp -R "$src/." "$dest/"
}

export_file() {
  local src="$1"
  local dest="$2"
  [[ -f "$src" ]] || return
  msg "  ðŸ“¤ $src -> $dest"
  mkdir -p "$(dirname "$dest")"
  if is_truthy "$DRY_RUN"; then
    msg "  ðŸ”Ž (dry-run) cp $src $dest"
    return
  fi
  cp "$src" "$dest"
}

normalize_crlf_to_lf() {
  local file="$1"
  [[ -f "$file" ]] || return 0

  # SÃ³ faz sentido em ambientes Unix; no Windows CRLF pode ser desejado.
  [[ "${TARGET_OS:-}" == "windows" ]] && return 0

  # Detecta carriage return (CR) e remove de forma portÃ¡til (sem sed -i especÃ­fico por OS)
  if LC_ALL=C grep -q $'\r' "$file" 2>/dev/null; then
    local tmp
    if ! tmp="$(mktemp)"; then
      warn "Falha ao criar arquivo temporÃ¡rio para normalizar $file"
      return 1
    fi

    if tr -d '\r' <"$file" >"$tmp" && mv "$tmp" "$file"; then
      return 0
    else
      warn "Falha ao normalizar line endings em $file"
      rm -f "$tmp" 2>/dev/null || true
      return 1
    fi
  fi
}

set_ssh_permissions() {
  if [[ -d "$HOME/.ssh" ]]; then
    chmod 700 "$HOME/.ssh"
    # Usar find para evitar problemas com globbing e nomes de arquivo com espaÃ§os
    find "$HOME/.ssh" -type f -exec chmod 600 {} + 2>/dev/null || true
    find "$HOME/.ssh" -type d -exec chmod 700 {} + 2>/dev/null || true
  fi
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SeleÃ§Ã£o Interativa de Apps GUI
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Arrays globais para armazenar seleÃ§Ãµes de apps
# shellcheck disable=SC2034
declare -a SELECTED_BROWSERS=()
# shellcheck disable=SC2034
declare -a SELECTED_DEV_TOOLS=()
# shellcheck disable=SC2034
declare -a SELECTED_DATABASES=()
# shellcheck disable=SC2034
declare -a SELECTED_PRODUCTIVITY=()
# shellcheck disable=SC2034
declare -a SELECTED_COMMUNICATION=()
# shellcheck disable=SC2034
declare -a SELECTED_MEDIA=()
# shellcheck disable=SC2034
declare -a SELECTED_UTILITIES=()
# shellcheck disable=SC2034
declare -a SELECTED_RUNTIMES=()
# shellcheck disable=SC2034
INTERACTIVE_GUI_APPS=true

# VariÃ¡vel de controle: se false, nÃ£o pergunta e instala tudo (comportamento antigo)
INSTALL_BREWFILE=true  # macOS only: instalar apps do Brewfile
STARSHIP_PRESET_DEFAULT="catppuccin-powerline"

# Carregar dados de apps/runtimes
# shellcheck disable=SC1091
if [[ -f "$DATA_APPS" ]]; then
  # shellcheck source=./data/apps.sh
  # shellcheck disable=SC1091
  source "$DATA_APPS"
else
  warn "Arquivo de dados de apps nÃ£o encontrado: $DATA_APPS"
fi
if [[ -f "$DATA_RUNTIMES" ]]; then
  # shellcheck source=./data/runtimes.sh
  # shellcheck disable=SC1091
  source "$DATA_RUNTIMES"
else
  warn "Arquivo de dados de runtimes nÃ£o encontrado: $DATA_RUNTIMES"
fi
# Libs
if [[ -f "$SCRIPT_DIR/lib/gui_apps.sh" ]]; then
  # shellcheck source=./lib/gui_apps.sh
  # shellcheck disable=SC1091
  source "$SCRIPT_DIR/lib/gui_apps.sh"
fi
if [[ -f "$SCRIPT_DIR/lib/runtimes.sh" ]]; then
  # shellcheck source=./lib/runtimes.sh
  # shellcheck disable=SC1091
  source "$SCRIPT_DIR/lib/runtimes.sh"
fi
if [[ -f "$SCRIPT_DIR/lib/report.sh" ]]; then
  # shellcheck source=./lib/report.sh
  # shellcheck disable=SC1091
  source "$SCRIPT_DIR/lib/report.sh"
fi

# shellcheck disable=SC2329
print_selection_summary() {
  local label="$1"
  shift
  local items=("$@")
  local list="(nenhum)"
  if [[ ${#items[@]} -gt 0 ]]; then
    list="$(printf "%s, " "${items[@]}")"
    list="${list%, }"
  fi
  msg "  â€¢ $label: $list"
}

ask_yes_no() {
  local prompt="$1"
  local response
  while true; do
    read -r -p "$prompt (s/n): " response
    case "$response" in
      [SsYy]*) return 0 ;;
      [Nn]*) return 1 ;;
      *) msg "  âš ï¸ Responda 's' para sim ou 'n' para nÃ£o" ;;
    esac
  done
}

ask_shells() {
  if ask_yes_no "Instalar e configurar Zsh?"; then
    INSTALL_ZSH=1
  else
    INSTALL_ZSH=0
  fi
  if ask_yes_no "Instalar e configurar Fish?"; then
    INSTALL_FISH=1
  else
    INSTALL_FISH=0
  fi
}

ask_optional_tools() {
  if ask_yes_no "Instalar Atuin (histÃ³rico avanÃ§ado)?"; then
    INSTALL_ATUIN=1
  else
    INSTALL_ATUIN=0
  fi
  if ask_yes_no "Instalar spec-kit (spec-driven dev)?"; then
    INSTALL_SPEC_KIT=1
  else
    INSTALL_SPEC_KIT=0
  fi
}

print_error_block() {
  local title="$1"
  shift
  local items=("$@")
  if [[ ${#items[@]} -eq 0 ]]; then
    return
  fi
  msg "  $title"
  for item in "${items[@]}"; do
    msg "   - $item"
  done
  msg ""
}

print_final_summary() {
  local force_exit="${1:-}"
  local exit_code=0
  if [[ ${#CRITICAL_ERRORS[@]} -gt 0 ]]; then
    exit_code=1
  fi
  if [[ -n "$force_exit" ]]; then
    exit_code="$force_exit"
  fi

  msg ""
  msg "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  msg "  ðŸ§¾ Resumo final (${MODE})"
  msg "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  print_error_block "âŒ Falhas crÃ­ticas:" "${CRITICAL_ERRORS[@]}"
  print_error_block "âš ï¸  Falhas opcionais:" "${OPTIONAL_ERRORS[@]}"

  if [[ ${#CRITICAL_ERRORS[@]} -eq 0 ]]; then
    msg "  âœ… ExecuÃ§Ã£o concluÃ­da sem falhas crÃ­ticas."
  else
    msg "  âŒ ExecuÃ§Ã£o finalizada com falhas crÃ­ticas."
  fi

  msg ""
  exit "$exit_code"
}

detect_os() {
  case "${OSTYPE:-}" in
    linux*)
      # Detectar WSL2 (Windows Subsystem for Linux)
      if grep -qiE '(microsoft|wsl)' /proc/version 2>/dev/null; then
        echo "wsl2"
      else
        echo "linux"
      fi
      ;;
    darwin*) echo "macos" ;;
    msys*|cygwin*|win32*) echo "windows" ;;
    *) echo "linux" ;;
  esac
}

# FunÃ§Ã£o auxiliar para verificar se Ã© WSL2
is_wsl2() {
  [[ "$TARGET_OS" == "wsl2" ]]
}

detect_linux_pkg_manager() {
  [[ -n "$LINUX_PKG_MANAGER" ]] && return
  for candidate in apt-get dnf pacman zypper; do
    if has_cmd "$candidate"; then
      LINUX_PKG_MANAGER="$candidate"
      return
    fi
  done
}

linux_pkg_update_cache() {
  [[ $LINUX_PKG_UPDATED -eq 1 ]] && return
  case "$LINUX_PKG_MANAGER" in
    apt-get)
      if run_with_sudo apt-get update -qq >/dev/null 2>&1; then
        LINUX_PKG_UPDATED=1
      fi
      ;;
    dnf)
      if run_with_sudo dnf makecache --refresh >/dev/null 2>&1; then
        LINUX_PKG_UPDATED=1
      fi
      ;;
    zypper)
      if run_with_sudo zypper refresh >/dev/null 2>&1; then
        LINUX_PKG_UPDATED=1
      fi
      ;;
    *)
      LINUX_PKG_UPDATED=1
      ;;
  esac
}

install_linux_packages() {
  local level="$1"
  shift
  local packages=("$@")
  [[ ${#packages[@]} -gt 0 ]] || return 0
  detect_linux_pkg_manager
  if [[ -z "$LINUX_PKG_MANAGER" ]]; then
    record_failure "$level" "Nenhum gerenciador de pacotes suportado encontrado (apt, dnf, pacman, zypper). Instale manualmente: ${packages[*]}"
    return 0
  fi
  linux_pkg_update_cache
  case "$LINUX_PKG_MANAGER" in
    apt-get)
      if ! run_with_sudo apt-get install -y "${packages[@]}"; then
        record_failure "$level" "Falha ao instalar (apt) ${packages[*]}"
      else
        INSTALLED_PACKAGES+=("apt: ${packages[*]}")
      fi
      ;;
    dnf)
      if ! run_with_sudo dnf install -y "${packages[@]}"; then
        record_failure "$level" "Falha ao instalar (dnf) ${packages[*]}"
      else
        INSTALLED_PACKAGES+=("dnf: ${packages[*]}")
      fi
      ;;
    pacman)
      if ! run_with_sudo pacman -Sy --noconfirm --needed "${packages[@]}"; then
        record_failure "$level" "Falha ao instalar (pacman) ${packages[*]}"
      else
        INSTALLED_PACKAGES+=("pacman: ${packages[*]}")
      fi
      ;;
    zypper)
      if ! run_with_sudo zypper install -y "${packages[@]}"; then
        record_failure "$level" "Falha ao instalar (zypper) ${packages[*]}"
      else
        INSTALLED_PACKAGES+=("zypper: ${packages[*]}")
      fi
      ;;
  esac
}

install_chrome_linux() {
  # Suporte automÃ¡tico apenas para distros baseadas em apt (Ubuntu/Debian)
  detect_linux_pkg_manager
  if has_cmd google-chrome || command -v google-chrome-stable >/dev/null 2>&1 || has_flatpak_ref "com.google.Chrome"; then
    return 0
  fi
  if [[ "$LINUX_PKG_MANAGER" != "apt-get" ]]; then
    record_failure "optional" "Google Chrome (Linux) suportado automaticamente apenas em distros apt; instale manualmente."
    return 0
  fi
  local deb=""
  deb="$(mktemp /tmp/google-chrome-XXXXXX.deb)"
  msg "  ðŸ“¦ Baixando Google Chrome para Linux..."
  if curl -fsSL "https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb" -o "$deb"; then
    if run_with_sudo dpkg -i "$deb"; then
      msg "  âœ… Google Chrome instalado"
      INSTALLED_MISC+=("google-chrome: deb")
      run_with_sudo apt-get install -f -y >/dev/null 2>&1 || true
    else
      record_failure "optional" "Falha ao instalar Google Chrome via dpkg"
    fi
  else
    record_failure "optional" "Falha ao baixar Google Chrome"
  fi
  rm -f "$deb"
}

install_brave_linux() {
  if has_cmd brave-browser; then
    return 0
  fi
  if has_cmd flatpak; then
    flatpak_install_or_update com.brave.Browser "Brave" optional
    return 0
  fi
  if has_cmd snap; then
    snap_install_or_refresh brave "Brave" optional
    return 0
  fi
  record_failure "optional" "Brave nÃ£o instalado: Flatpak/Snap indisponÃ­veis nesta distro."
}

install_zen_linux() {
  if has_cmd zen-browser; then
    return 0
  fi
  if has_cmd flatpak; then
    flatpak_install_or_update io.github.ranfdev.Zen "Zen Browser" optional
    return 0
  fi
  record_failure "optional" "Zen Browser nÃ£o instalado: Flatpak indisponÃ­vel nesta distro."
}

install_pgadmin_linux() {
  if has_cmd pgadmin4; then
    return 0
  fi
  if has_cmd flatpak; then
    flatpak_install_or_update org.pgadmin.pgadmin4 "pgAdmin" optional
    return 0
  fi
  record_failure "optional" "pgAdmin nÃ£o instalado: Flatpak indisponÃ­vel nesta distro."
}

install_mongodb_linux() {
  if has_cmd mongod || has_cmd mongodb-compass; then
    return 0
  fi
  if has_cmd flatpak; then
    flatpak_install_or_update com.mongodb.Compass "MongoDB Compass" optional
    return 0
  fi
  install_linux_packages optional mongodb 2>/dev/null
}

install_vscode_linux() {
  # Objetivo: garantir VS Code Stable o mais recente possÃ­vel no Linux.
  # PreferÃªncia: instalador oficial (latest .deb/.rpm). Fallback: snap/flatpak.

  # Se jÃ¡ estiver instalado via Snap, apenas atualiza no canal stable.
  if has_snap_pkg code; then
    msg "  ðŸ”„ Atualizando VS Code via snap (stable)..."
    if run_with_sudo snap refresh code --channel=stable >/dev/null 2>&1; then
      INSTALLED_MISC+=("vscode: snap refresh (stable)")
    else
      record_failure "optional" "Falha ao atualizar VS Code via snap"
    fi
    return 0
  fi

  # Se jÃ¡ estiver instalado via Flatpak, apenas atualiza.
  if has_flatpak_ref "com.visualstudio.code"; then
    msg "  ðŸ”„ Atualizando VS Code via flatpak..."
    if flatpak update -y com.visualstudio.code >/dev/null 2>&1; then
      INSTALLED_MISC+=("vscode: flatpak update")
    else
      record_failure "optional" "Falha ao atualizar VS Code via flatpak"
    fi
    return 0
  fi

  detect_linux_pkg_manager

  # Preferir pacotes oficiais do site (sempre apontam para o Ãºltimo stable).
  if [[ "$LINUX_PKG_MANAGER" == "apt-get" ]]; then
    if has_cmd code; then
      msg "  ðŸ”„ Atualizando VS Code (deb oficial)..."
    else
      msg "  ðŸ“¦ Instalando VS Code (deb oficial)..."
    fi

    local deb=""
    deb="$(mktemp /tmp/vscode-XXXXXX.deb)"
    if curl -fsSL "https://code.visualstudio.com/sha/download?build=stable&os=linux-deb-x64" -o "$deb"; then
      if run_with_sudo dpkg -i "$deb" >/dev/null 2>&1; then
        INSTALLED_MISC+=("vscode: deb oficial (stable)")
      else
        # Resolver dependÃªncias quebradas (dpkg -i pode falhar por deps)
        run_with_sudo apt-get install -f -y >/dev/null 2>&1 || true
        if run_with_sudo dpkg -i "$deb" >/dev/null 2>&1; then
          INSTALLED_MISC+=("vscode: deb oficial (stable)")
        else
          record_failure "optional" "Falha ao instalar VS Code (deb)"
        fi
      fi
      rm -f "$deb" >/dev/null 2>&1 || true
      return 0
    fi
    rm -f "$deb" >/dev/null 2>&1 || true
    record_failure "optional" "Falha ao baixar VS Code (deb oficial)"
  fi

  if [[ "$LINUX_PKG_MANAGER" == "dnf" ]]; then
    msg "  ðŸ“¦ Instalando VS Code (rpm oficial via dnf)..."
    if run_with_sudo dnf install -y "https://code.visualstudio.com/sha/download?build=stable&os=linux-rpm-x64" >/dev/null 2>&1; then
      INSTALLED_MISC+=("vscode: rpm oficial (stable)")
    else
      record_failure "optional" "Falha ao instalar VS Code via dnf (rpm oficial)"
    fi
    return 0
  fi

  if [[ "$LINUX_PKG_MANAGER" == "zypper" ]]; then
    msg "  ðŸ“¦ Instalando VS Code (rpm oficial via zypper)..."
    if run_with_sudo zypper install -y "https://code.visualstudio.com/sha/download?build=stable&os=linux-rpm-x64" >/dev/null 2>&1; then
      INSTALLED_MISC+=("vscode: rpm oficial (stable)")
    else
      record_failure "optional" "Falha ao instalar VS Code via zypper (rpm oficial)"
    fi
    return 0
  fi

  # Fallbacks quando nÃ£o dÃ¡ pra usar .deb/.rpm.
  if has_cmd snap; then
    msg "  ðŸ“¦ Instalando VS Code via snap (stable)..."
    if run_with_sudo snap install code --classic --channel=stable >/dev/null 2>&1; then
      INSTALLED_MISC+=("vscode: snap install (stable)")
    else
      record_failure "optional" "Falha ao instalar VS Code via snap"
    fi
    return 0
  fi

  if has_cmd flatpak; then
    msg "  ðŸ“¦ Instalando VS Code via flatpak..."
    flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo >/dev/null 2>&1 || true
    if flatpak install -y flathub com.visualstudio.code >/dev/null 2>&1; then
      INSTALLED_MISC+=("vscode: flatpak install")
    else
      record_failure "optional" "Falha ao instalar VS Code via flatpak"
    fi
    return 0
  fi

  record_failure "optional" "VS Code nÃ£o instalado: apt/dnf/zypper/snap/flatpak indisponÃ­veis nesta distro."
  return 0
}

install_vscode_macos() {
  # Objetivo: garantir VS Code Stable o mais recente possÃ­vel no macOS.
  # PreferÃªncia: Homebrew cask (bem mantido). Fallback: nÃ£o automatizado.

  if has_cmd brew; then
    msg "  ðŸº VS Code via Homebrew..."
    if brew list --cask visual-studio-code >/dev/null 2>&1; then
      if should_ensure_latest; then
        if brew upgrade --cask visual-studio-code >/dev/null 2>&1; then
          INSTALLED_PACKAGES+=("brew cask: visual-studio-code (upgrade)")
        else
          record_failure "optional" "Falha ao atualizar VS Code via Homebrew cask"
        fi
      fi
      return 0
    fi

    if brew install --cask visual-studio-code >/dev/null 2>&1; then
      INSTALLED_PACKAGES+=("brew cask: visual-studio-code (install)")
      return 0
    fi

    record_failure "optional" "Falha ao instalar VS Code via Homebrew cask"
    return 0
  fi

  record_failure "optional" "Homebrew nÃ£o disponÃ­vel: nÃ£o foi possÃ­vel instalar VS Code automaticamente no macOS"
  return 0
}

install_vscode_windows() {
  # Objetivo: garantir VS Code Stable o mais recente possÃ­vel no Windows.
  # PreferÃªncia: winget (upgrade/install). Fallback: Chocolatey.

  if has_cmd winget; then
    local id="Microsoft.VisualStudioCode"
    local result=""
    result="$(winget list --id "$id" 2>/dev/null || true)"
    if [[ "$result" == *"$id"* ]]; then
      if should_ensure_latest; then
        if winget upgrade --id "$id" -e --accept-package-agreements --accept-source-agreements >/dev/null 2>&1; then
          INSTALLED_PACKAGES+=("winget: VS Code (upgrade)")
        else
          record_failure "optional" "Falha ao atualizar VS Code via winget"
        fi
      fi
      return 0
    fi

    if winget install --id "$id" -e --accept-package-agreements --accept-source-agreements >/dev/null 2>&1; then
      INSTALLED_PACKAGES+=("winget: VS Code (install)")
    else
      record_failure "optional" "Falha ao instalar VS Code via winget"
    fi
    return 0
  fi

  if has_cmd choco; then
    local package="vscode"
    local result=""
    result="$(choco list --local-only "$package" 2>/dev/null || true)"
    if [[ "$result" == *"$package"* ]]; then
      if should_ensure_latest; then
        if choco upgrade -y "$package" >/dev/null 2>&1; then
          INSTALLED_PACKAGES+=("choco: vscode (upgrade)")
        else
          record_failure "optional" "Falha ao atualizar VS Code via Chocolatey"
        fi
      fi
      return 0
    fi

    if choco install -y "$package" >/dev/null 2>&1; then
      INSTALLED_PACKAGES+=("choco: vscode (install)")
    else
      record_failure "optional" "Falha ao instalar VS Code via Chocolatey"
    fi
    return 0
  fi

  record_failure "optional" "VS Code nÃ£o instalado: winget/Chocolatey nÃ£o disponÃ­veis"
  return 0
}

install_vscode() {
  case "${TARGET_OS:-}" in
    linux|wsl2) install_vscode_linux ;;
    macos) install_vscode_macos ;;
    windows) install_vscode_windows ;;
  esac
}

install_docker_linux() {
  # Objetivo: garantir Docker Engine + compose plugin pelo gerenciador nativo.
  if has_cmd docker; then
    return 0
  fi

  detect_linux_pkg_manager
  case "$LINUX_PKG_MANAGER" in
    apt-get)
      install_linux_packages optional docker.io docker-compose-plugin
      ;;
    dnf)
      install_linux_packages optional docker docker-compose
      ;;
    pacman)
      install_linux_packages optional docker docker-compose
      ;;
    zypper)
      install_linux_packages optional docker docker-compose
      ;;
    *)
      record_failure "optional" "Docker nÃ£o instalado: gerenciador nÃ£o suportado para Docker Engine."
      ;;
  esac
}

# shellcheck disable=SC2329
install_php_build_deps_linux() {
  # DependÃªncias de build necessÃ¡rias para compilar PHP (mise/asdf-php).
  detect_linux_pkg_manager
  case "$LINUX_PKG_MANAGER" in
    apt-get)
      install_linux_packages optional \
        autoconf bison build-essential pkg-config re2c plocate \
        libgd-dev libcurl4-openssl-dev libedit-dev libicu-dev libjpeg-dev \
        libmysqlclient-dev libonig-dev libpng-dev libpq-dev libreadline-dev \
        libsqlite3-dev libssl-dev libxml2-dev libxslt-dev libzip-dev \
        gettext git curl openssl
      ;;
    dnf)
      install_linux_packages optional \
        autoconf bison gcc gcc-c++ make pkg-config re2c mlocate \
        gd-devel libzip-devel libxml2-devel libxslt-devel libcurl-devel \
        libedit-devel libicu-devel libjpeg-turbo-devel libpng-devel \
        libpq-devel readline-devel sqlite-devel openssl-devel oniguruma-devel \
        gettext-devel git curl openssl mysql-devel
      ;;
    pacman)
      install_linux_packages optional \
        autoconf bison base-devel pkgconf re2c mlocate \
        gd libzip libxml2 libxslt curl libedit icu libjpeg-turbo libpng \
        libpq readline sqlite openssl oniguruma gettext git mariadb-libs
      ;;
    zypper)
      install_linux_packages optional \
        autoconf bison gcc gcc-c++ make pkg-config re2c mlocate \
        gd-devel libzip-devel libxml2-devel libxslt-devel libcurl-devel \
        libedit-devel libicu-devel libjpeg8-devel libpng16-devel libpq-devel \
        readline-devel sqlite3-devel libopenssl-devel oniguruma-devel \
        gettext-tools git curl libmysqlclient-devel
      ;;
  esac
}

# shellcheck disable=SC2329
install_php_build_deps_macos() {
  # DependÃªncias de build necessÃ¡rias para compilar PHP (mise/asdf-php) no macOS.
  # Evitamos instalÃ¡-las sempre; sÃ³ chamamos quando o runtime PHP Ã© selecionado.
  local deps=(
    autoconf
    bison
    re2c
    pkg-config
    libzip
    icu4c
    openssl@3
    readline
    gettext
    curl
  )
  local dep=""
  for dep in "${deps[@]}"; do
    brew_install_formula "$dep" optional
  done
}

# shellcheck disable=SC2329
install_php_windows() {
  # Preferir binÃ¡rio pronto no Windows (winget/choco) em vez de compilar via mise.
  local installed=0
  if has_cmd winget; then
    # Tenta a versÃ£o genÃ©rica (latest) e depois uma especÃ­fica.
    winget_install PHP.PHP "PHP" optional
    if has_cmd php; then
      installed=1
    else
      winget_install PHP.PHP.8.3 "PHP 8.3" optional
      has_cmd php && installed=1
    fi
  fi

  if [[ $installed -eq 0 ]] && has_cmd choco; then
    choco_install php "PHP (latest)" optional
    has_cmd php && installed=1
  fi

  if [[ $installed -eq 1 ]]; then
    msg "  âœ… PHP (latest) instalado/atualizado no Windows (winget/choco)"
    return 0
  fi

  record_failure "optional" "PHP nÃ£o instalado no Windows: winget/choco indisponÃ­veis ou falharam"
  return 1
}

# shellcheck disable=SC2329
install_composer_and_laravel() {
  # Instala Composer (via mise) e Laravel installer (via Composer global) se ainda nÃ£o existirem.
  if ! has_cmd composer; then
    if has_cmd mise; then
      msg "  ðŸ“¦ Composer (latest) via mise..."
      if ! mise use -g -y composer@latest >/dev/null 2>&1; then
        record_failure "optional" "Falha ao instalar Composer via mise"
        return
      fi
    else
      record_failure "optional" "Composer nÃ£o instalado: mise ausente"
      return
    fi
  fi

  if ! has_cmd laravel; then
    msg "  ðŸ“¦ Laravel installer via Composer..."
    if composer global require laravel/installer >/dev/null 2>&1; then
      # Garantir que o binÃ¡rio global esteja acessÃ­vel (via symlink em ~/.local/bin)
      local bin_dir=""
      bin_dir="$(composer global config bin-dir --absolute 2>/dev/null || true)"
      if [[ -n "$bin_dir" && -x "$bin_dir/laravel" ]]; then
        mkdir -p "$HOME/.local/bin"
        if [[ ! -e "$HOME/.local/bin/laravel" ]]; then
          ln -s "$bin_dir/laravel" "$HOME/.local/bin/laravel" 2>/dev/null || true
        fi
      fi
    else
      record_failure "optional" "Falha ao instalar Laravel installer via Composer"
    fi
  fi
}

ensure_rust_cargo() {
  if has_cmd cargo; then
    return 0
  fi

  msg "â–¶ Rust/Cargo nÃ£o encontrado. Instalando..."

  if curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --no-modify-path >/dev/null 2>&1; then
    # Adicionar cargo ao PATH da sessÃ£o atual
    export PATH="$HOME/.cargo/bin:$PATH"
    INSTALLED_MISC+=("rustup: installer script")
    msg "  âœ… Rust/Cargo instalado com sucesso"
    return 0
  else
    record_failure "critical" "Falha ao instalar Rust/Cargo. Algumas ferramentas nÃ£o estarÃ£o disponÃ­veis."
    return 1
  fi
}

ensure_ghostty_linux() {
  if has_cmd ghostty; then
    return
  fi

  msg "â–¶ Ghostty nÃ£o encontrado. Tentando instalar..."

  # Detectar distro
  local distro=""
  if [[ -f /etc/os-release ]]; then
    # shellcheck disable=SC1091
    distro="$(. /etc/os-release && echo "$ID")"
  fi

  case "$distro" in
    ubuntu|pop|neon)
      msg "  ðŸ“¦ Ubuntu/derivados detectado. Instalando via script mkasberg..."
      if bash -c "$(curl -fsSL https://raw.githubusercontent.com/mkasberg/ghostty-ubuntu/HEAD/install.sh)" >/dev/null 2>&1; then
        msg "  âœ… Ghostty instalado com sucesso"
        INSTALLED_MISC+=("ghostty: mkasberg script")
        return 0
      fi
      ;;
    debian)
      msg "  ðŸ“¦ Debian detectado. Instalando via repositÃ³rio griffo.io..."
      if curl -sS https://debian.griffo.io/EA0F721D231FDD3A0A17B9AC7808B4DD62C41256.asc | run_with_sudo gpg --dearmor --yes -o /etc/apt/trusted.gpg.d/debian.griffo.io.gpg 2>/dev/null; then
        echo "deb https://debian.griffo.io/apt $(lsb_release -sc 2>/dev/null || echo "bookworm") main" | run_with_sudo tee /etc/apt/sources.list.d/debian.griffo.io.list >/dev/null
        run_with_sudo apt-get update >/dev/null 2>&1
        if run_with_sudo apt-get install -y ghostty >/dev/null 2>&1; then
          msg "  âœ… Ghostty instalado com sucesso"
          INSTALLED_MISC+=("ghostty: apt")
          return 0
        fi
      fi
      ;;
    arch|manjaro|endeavouros)
      msg "  ðŸ“¦ Arch/derivados detectado. Instalando via pacman..."
      if run_with_sudo pacman -Sy --noconfirm --needed ghostty >/dev/null 2>&1; then
        msg "  âœ… Ghostty instalado com sucesso"
        INSTALLED_MISC+=("ghostty: pacman")
        return 0
      fi
      ;;
    fedora|rhel|centos|rocky|almalinux)
      msg "  ðŸ“¦ Fedora/RHEL detectado. Tentando via snap..."
      if has_cmd snap; then
        snap_install_or_refresh ghostty "Ghostty" optional --classic
        if has_cmd ghostty; then
          msg "  âœ… Ghostty instalado via snap"
          return 0
        fi
      fi
      ;;
    opensuse*|suse)
      msg "  ðŸ“¦ openSUSE detectado. Instalando via zypper..."
      if run_with_sudo zypper install -y ghostty >/dev/null 2>&1; then
        msg "  âœ… Ghostty instalado com sucesso"
        INSTALLED_MISC+=("ghostty: zypper")
        return 0
      fi
      ;;
  esac

  # Fallback: Tentar Flatpak
  if has_cmd flatpak; then
    if ! flatpak info com.mitchellh.ghostty >/dev/null 2>&1; then
      msg "  ðŸ“¦ Tentando instalar via Flatpak..."
      flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo >/dev/null 2>&1 || true
      if flatpak install -y flathub com.mitchellh.ghostty >/dev/null 2>&1; then
        msg "  âœ… Ghostty instalado via Flatpak"
        INSTALLED_MISC+=("ghostty: flatpak")
        return 0
      fi
    fi
  fi

  # Fallback: Tentar Snap
  if has_cmd snap; then
    if run_with_sudo snap install ghostty --classic >/dev/null 2>&1; then
      msg "  âœ… Ghostty instalado via snap"
      INSTALLED_MISC+=("ghostty: snap")
      return 0
    fi
  fi

  record_failure "critical" "NÃ£o foi possÃ­vel instalar Ghostty automaticamente."
  msg "  â„¹ï¸  Visite https://ghostty.org para instruÃ§Ãµes de instalaÃ§Ã£o manual."
  return 1
}

ensure_uv() {
  if has_cmd uv; then
    return 0
  fi

  msg "â–¶ uv (Python Package Manager) nÃ£o encontrado. Instalando..."

  # Tentar via script oficial
  if curl -LsSf https://astral.sh/uv/install.sh | sh >/dev/null 2>&1; then
    # Adicionar uv ao PATH da sessÃ£o atual
    export PATH="$HOME/.local/bin:$PATH"
    INSTALLED_MISC+=("uv: installer script")
    msg "  âœ… uv instalado com sucesso"

    # Gerar completions para shells
    if has_cmd fish && [[ -d "$HOME/.config/fish/completions" ]]; then
      uv generate-shell-completion fish > "$HOME/.config/fish/completions/uv.fish" 2>/dev/null
    fi
    if has_cmd zsh && [[ -d "$HOME/.oh-my-zsh/completions" ]]; then
      uv generate-shell-completion zsh > "$HOME/.oh-my-zsh/completions/_uv" 2>/dev/null
    fi

    return 0
  else
    record_failure "critical" "Falha ao instalar uv. Python packages precisarÃ£o ser instalados manualmente."
    return 1
  fi
}

# shellcheck disable=SC2329
ensure_mise() {
  if has_cmd mise; then
    return 0
  fi

  msg "â–¶ mise (runtime manager) nÃ£o encontrado. Instalando..."

  # Em macOS, preferir Homebrew quando disponÃ­vel
  if [[ "${TARGET_OS:-}" == "macos" ]] && has_cmd brew; then
    if brew install mise >/dev/null 2>&1; then
      INSTALLED_PACKAGES+=("brew: mise (install)")
      msg "  âœ… mise instalado via Homebrew"
      return 0
    fi
  fi

  # Fallback cross-platform: instalador standalone
  if curl -fsSL https://mise.run | sh >/dev/null 2>&1; then
    export PATH="$HOME/.local/bin:$PATH"
    INSTALLED_MISC+=("mise: installer script")
    msg "  âœ… mise instalado com sucesso"
    return 0
  fi

  record_failure "critical" "Falha ao instalar mise. Instale manualmente (https://mise.jdx.dev/installing-mise.html)."
  return 1
}

ensure_spec_kit() {
  # Verificar se uv estÃ¡ instalado (necessÃ¡rio para spec-kit)
  if ! has_cmd uv; then
    record_failure "optional" "uv nÃ£o encontrado. spec-kit precisa de uv instalado."
    msg "  ðŸ’¡ Execute: curl -LsSf https://astral.sh/uv/install.sh | sh"
    return 1
  fi

  # Verificar se specify jÃ¡ estÃ¡ instalado
  if has_cmd specify; then
    local spec_version
    spec_version="$(specify --version 2>/dev/null | head -n1 || echo 'unknown')"
    msg "  â„¹ï¸  spec-kit jÃ¡ instalado: $spec_version"

    # Oferecer atualizaÃ§Ã£o se estiver desatualizado
    if uv tool list 2>/dev/null | grep -q "specify-cli"; then
      msg "  ðŸ’¡ Para atualizar: uv tool upgrade specify-cli"
    fi
    return 0
  fi

  msg "â–¶ spec-kit (Spec-Driven Development) nÃ£o encontrado. Instalando..."
  msg "  ðŸ“š Spec-Kit: Toolkit do GitHub para desenvolvimento guiado por especificaÃ§Ãµes"
  msg "  ðŸ¤– Integra com Claude para gerar especificaÃ§Ãµes e implementaÃ§Ãµes"

  # Instalar spec-kit via uv tool
  local install_output
  install_output="$(uv tool install specify-cli --from git+https://github.com/github/spec-kit.git 2>&1)"
  local install_status=$?

  if [[ $install_status -eq 0 ]]; then
    # Adicionar ao PATH da sessÃ£o atual
    export PATH="$HOME/.local/bin:$PATH"

    # Verificar se o comando estÃ¡ disponÃ­vel agora
    if has_cmd specify; then
      local installed_version
      installed_version="$(specify --version 2>/dev/null | head -n1 || echo 'instalado')"
      msg "  âœ… spec-kit instalado com sucesso: $installed_version"
      INSTALLED_MISC+=("spec-kit: uv tool install")
      msg ""
      msg "  ðŸ“– Como usar o spec-kit:"
      msg "     â€¢ specify init <projeto> --ai claude  # Inicializar com Claude"
      msg "     â€¢ specify generate                     # Gerar implementaÃ§Ã£o"
      msg "     â€¢ specify validate                     # Validar especificaÃ§Ã£o"
      msg "     â€¢ specify --help                       # Ver todos os comandos"
      msg ""
      return 0
    else
      record_failure "optional" "spec-kit instalado mas comando 'specify' nÃ£o encontrado no PATH"
      msg "  ðŸ’¡ Reinicie o shell ou adicione ~/.local/bin ao PATH"
      return 1
    fi
  else
    record_failure "optional" "Falha ao instalar spec-kit"
    msg "  ðŸ“‹ SaÃ­da do erro:"
    echo "$install_output" | head -n5 | sed 's/^/     /'
    msg ""
    msg "  ðŸ”§ Tente instalar manualmente:"
    msg "     uv tool install specify-cli --from git+https://github.com/github/spec-kit.git"
    msg ""
    msg "  ðŸ“š Mais informaÃ§Ãµes: https://github.com/github/spec-kit"
    return 1
  fi
}

ensure_atuin() {
  if has_cmd atuin; then
    return 0
  fi

  msg "â–¶ Atuin (Better Shell History) nÃ£o encontrado. Instalando..."

  # Tentar via script oficial
  if curl --proto '=https' --tlsv1.2 -LsSf https://setup.atuin.sh | sh -s -- --yes >/dev/null 2>&1; then
    # Adicionar atuin ao PATH da sessÃ£o atual
    export PATH="$HOME/.atuin/bin:$PATH"
    export PATH="$HOME/.local/bin:$PATH"
    INSTALLED_MISC+=("atuin: installer script")
    msg "  âœ… Atuin instalado com sucesso"
    msg "  ðŸ’¡ Atuin sincroniza histÃ³rico de comandos entre mÃ¡quinas"
    msg "  ðŸ’¡ Use 'atuin register' para criar conta e sincronizar"
    msg "  ðŸ’¡ Use 'atuin login' se jÃ¡ tiver conta"

    # Gerar completions e configuraÃ§Ã£o para shells
    if has_cmd fish && [[ -d "$HOME/.config/fish" ]]; then
      # Adicionar init do atuin no config.fish se nÃ£o existir
      local fish_config="$HOME/.config/fish/config.fish"
      if [[ -f "$fish_config" ]] && ! grep -q "atuin init fish" "$fish_config"; then
        {
          echo ""
          echo "# Atuin - Better Shell History"
          echo "if type -q atuin"
          echo "  atuin init fish | source"
          echo "end"
        } >> "$fish_config"
      fi
    fi

    if has_cmd zsh && [[ -f "$HOME/.zshrc" ]]; then
      # Adicionar init do atuin no .zshrc se nÃ£o existir
      if ! grep -q "atuin init zsh" "$HOME/.zshrc"; then
        {
          echo ""
          echo "# Atuin - Better Shell History"
          # shellcheck disable=SC2016
          echo 'eval "$(atuin init zsh)"'
        } >> "$HOME/.zshrc"
      fi
    fi

    return 0
  else
    record_failure "critical" "Falha ao instalar Atuin. Tente manualmente: curl --proto '=https' --tlsv1.2 -LsSf https://setup.atuin.sh | sh"
    return 1
  fi
}

install_modern_cli_tools() {
  msg "â–¶ Instalando ferramentas CLI modernas"

  # Instalar ferramentas via cargo SOMENTE se necessÃ¡rio (evita instalar Rust/Cargo sem motivo)
  local need_cargo=0
  if ! has_cmd eza && ! has_cmd exa; then need_cargo=1; fi
  if ! has_cmd zoxide; then need_cargo=1; fi
  if ! has_cmd bat && ! has_cmd batcat; then need_cargo=1; fi
  if ! has_cmd delta; then need_cargo=1; fi
  if ! has_cmd tlrc && ! has_cmd tldr; then need_cargo=1; fi
  if ! has_cmd starship; then need_cargo=1; fi

  if [[ $need_cargo -eq 1 ]]; then
    ensure_rust_cargo
    if has_cmd cargo; then
      if ! has_cmd eza && ! has_cmd exa; then
        msg "  ðŸ¦€ Instalando eza via cargo..."
        if cargo install eza 2>/dev/null; then
          INSTALLED_MISC+=("cargo: eza")
        else
          record_failure "critical" "Falha ao instalar eza via cargo"
        fi
      fi

      if ! has_cmd zoxide; then
        msg "  ðŸ¦€ Instalando zoxide via cargo..."
        if cargo install zoxide 2>/dev/null; then
          INSTALLED_MISC+=("cargo: zoxide")
        else
          record_failure "critical" "Falha ao instalar zoxide via cargo"
        fi
      fi

      if ! has_cmd bat && ! has_cmd batcat; then
        msg "  ðŸ¦€ Instalando bat via cargo..."
        if cargo install bat 2>/dev/null; then
          INSTALLED_MISC+=("cargo: bat")
        else
          record_failure "critical" "Falha ao instalar bat via cargo"
        fi
      fi

      if ! has_cmd delta; then
        msg "  ðŸ¦€ Instalando git-delta via cargo..."
        if cargo install git-delta 2>/dev/null; then
          INSTALLED_MISC+=("cargo: git-delta")
        else
          record_failure "critical" "Falha ao instalar git-delta via cargo"
        fi
      fi

      if ! has_cmd tlrc && ! has_cmd tldr; then
        msg "  ðŸ¦€ Instalando tlrc via cargo..."
        if cargo install tlrc 2>/dev/null; then
          INSTALLED_MISC+=("cargo: tlrc")
        else
          record_failure "critical" "Falha ao instalar tlrc via cargo"
        fi
      fi

      if ! has_cmd starship; then
        msg "  ðŸ¦€ Instalando starship via cargo..."
        if cargo install starship 2>/dev/null; then
          INSTALLED_MISC+=("cargo: starship")
        else
          record_failure "critical" "Falha ao instalar starship via cargo"
        fi
      fi
    fi
  fi

  # Garantir que uv esteja instalado
  ensure_uv

  # Garantir que mise esteja instalado
  ensure_mise

  # Garantir que spec-kit esteja instalado
  if is_truthy "$INSTALL_SPEC_KIT"; then
    ensure_spec_kit
  fi

  # Garantir que Atuin esteja instalado (Better Shell History)
  if is_truthy "$INSTALL_ATUIN"; then
    ensure_atuin
  fi

  # Oh My Zsh (se zsh estiver instalado)
  if is_truthy "$INSTALL_ZSH" && has_cmd zsh && [[ ! -d "$HOME/.oh-my-zsh" ]]; then
    msg "  ðŸŽ¨ Instalando Oh My Zsh..."
    if ! CHSH=no RUNZSH=no sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" "" --unattended 2>/dev/null; then
      record_failure "critical" "Falha ao instalar Oh My Zsh"
    else
      INSTALLED_MISC+=("oh-my-zsh: installer script")
    fi
  fi

  # Powerlevel10k theme para Oh My Zsh
  if [[ -d "$HOME/.oh-my-zsh" ]] && [[ ! -d "$HOME/.oh-my-zsh/custom/themes/powerlevel10k" ]]; then
    msg "  âš¡ Instalando Powerlevel10k..."
    if git clone --depth=1 https://github.com/romkatv/powerlevel10k.git "$HOME/.oh-my-zsh/custom/themes/powerlevel10k" 2>/dev/null; then
      INSTALLED_MISC+=("powerlevel10k: git clone")
    else
      record_failure "critical" "Falha ao clonar Powerlevel10k"
    fi
  fi

  # Zsh plugins Ãºteis
  if is_truthy "$INSTALL_ZSH" && [[ -d "$HOME/.oh-my-zsh" ]]; then
    mkdir -p "$HOME/.oh-my-zsh/custom/plugins"

    if [[ ! -d "$HOME/.oh-my-zsh/custom/plugins/zsh-autosuggestions" ]]; then
      msg "  ðŸ”Œ Instalando zsh-autosuggestions..."
      if git clone --depth=1 https://github.com/zsh-users/zsh-autosuggestions "$HOME/.oh-my-zsh/custom/plugins/zsh-autosuggestions" 2>/dev/null; then
        INSTALLED_MISC+=("zsh-autosuggestions: git clone")
      else
        record_failure "critical" "Falha ao clonar zsh-autosuggestions"
      fi
    fi

    if [[ ! -d "$HOME/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting" ]]; then
      msg "  ðŸ”Œ Instalando zsh-syntax-highlighting..."
      if git clone --depth=1 https://github.com/zsh-users/zsh-syntax-highlighting.git "$HOME/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting" 2>/dev/null; then
        INSTALLED_MISC+=("zsh-syntax-highlighting: git clone")
      else
        record_failure "critical" "Falha ao clonar zsh-syntax-highlighting"
      fi
    fi

    if [[ ! -d "$HOME/.oh-my-zsh/custom/plugins/zsh-completions" ]]; then
      msg "  ðŸ”Œ Instalando zsh-completions..."
      if git clone --depth=1 https://github.com/zsh-users/zsh-completions "$HOME/.oh-my-zsh/custom/plugins/zsh-completions" 2>/dev/null; then
        INSTALLED_MISC+=("zsh-completions: git clone")
      else
        record_failure "critical" "Falha ao clonar zsh-completions"
      fi
    fi

    if [[ ! -d "$HOME/.oh-my-zsh/custom/plugins/zsh-autopair" ]]; then
      msg "  ðŸ”Œ Instalando zsh-autopair..."
      if git clone --depth=1 https://github.com/hlissner/zsh-autopair "$HOME/.oh-my-zsh/custom/plugins/zsh-autopair" 2>/dev/null; then
        INSTALLED_MISC+=("zsh-autopair: git clone")
      else
        record_failure "critical" "Falha ao clonar zsh-autopair"
      fi
    fi

    if [[ ! -d "$HOME/.oh-my-zsh/custom/plugins/zsh-history-substring-search" ]]; then
      msg "  ðŸ”Œ Instalando zsh-history-substring-search..."
      if git clone --depth=1 https://github.com/zsh-users/zsh-history-substring-search "$HOME/.oh-my-zsh/custom/plugins/zsh-history-substring-search" 2>/dev/null; then
        INSTALLED_MISC+=("zsh-history-substring-search: git clone")
      else
        record_failure "critical" "Falha ao clonar zsh-history-substring-search"
      fi
    fi
  fi
}

install_linux_prereqs() {
  detect_linux_pkg_manager

  # Pacotes base mudam de nome entre gerenciadores; se algum faltar, o script
  # continua graÃ§as aos fallbacks via cargo (install_modern_cli_tools).
  local base_packages=()
  local optional_packages=()

  case "$LINUX_PKG_MANAGER" in
    apt-get)
      base_packages=(
        build-essential  # toolchain C/C++
        pkg-config
        ca-certificates
        git
        curl
        wget
        gnupg
        lsb-release
        unzip
        zip
        tmux
        neovim
        vim
        nano
        fontconfig
      )
      optional_packages=(
        starship
        ripgrep
        fzf
        jq
        direnv
        bat
        fd-find
        btop
        htop
        eza
        zoxide
        delta
        lazygit
        gh
      )
      ;;
    dnf)
      base_packages=(
        gcc
        gcc-c++
        make
        pkg-config
        ca-certificates
        git
        curl
        wget
        gnupg2
        redhat-lsb-core
        unzip
        zip
        tmux
        neovim
        vim-enhanced
        nano
        fontconfig
      )
      optional_packages=(
        starship
        ripgrep
        fzf
        jq
        direnv
        bat
        fd-find
        btop
        htop
        eza
        zoxide
        git-delta
        lazygit
        gh
      )
      ;;
    pacman)
      base_packages=(
        base-devel
        pkgconf
        ca-certificates
        git
        curl
        wget
        gnupg
        lsb-release
        unzip
        zip
        tmux
        neovim
        vim
        nano
        fontconfig
      )
      optional_packages=(
        starship
        ripgrep
        fzf
        jq
        direnv
        bat
        fd
        btop
        htop
        eza
        zoxide
        git-delta
        lazygit
        github-cli
      )
      ;;
    zypper)
      base_packages=(
        gcc
        gcc-c++
        make
        pkg-config
        ca-certificates
        ca-certificates-mozilla
        git
        curl
        wget
        gpg2
        lsb-release
        unzip
        zip
        tmux
        neovim
        vim
        nano
        fontconfig
      )
      optional_packages=(
        starship
        ripgrep
        fzf
        jq
        direnv
        bat
        fd
        btop
        htop
        eza
        zoxide
        delta
        lazygit
        gh
      )
      ;;
    *)
      record_failure "critical" "Nenhum gerenciador de pacotes suportado encontrado (apt, dnf, pacman, zypper)."
      return
      ;;
  esac

  if is_truthy "$INSTALL_ZSH"; then
    base_packages+=(zsh)
  fi
  if is_truthy "$INSTALL_FISH"; then
    base_packages+=(fish)
  fi

  msg "â–¶ Verificando dependÃªncias Linux ($LINUX_PKG_MANAGER)"
  install_linux_packages critical "${base_packages[@]}"

  msg "â–¶ Instalando ferramentas opcionais"
  for pkg in "${optional_packages[@]}"; do
    install_linux_packages optional "$pkg" 2>/dev/null
  done

  msg "â–¶ Instalando apps cross-platform selecionados"

  # Browsers
  should_install_app firefox browsers && install_linux_packages optional firefox 2>/dev/null
  if should_install_app chrome browsers; then
    install_chrome_linux
  fi
  if should_install_app brave browsers; then
    install_brave_linux
  fi
  if should_install_app zen browsers; then
    install_zen_linux
  fi

  # Development Tools
  should_install_app vscode dev-tools && install_vscode
  should_install_app docker dev-tools && install_docker_linux

  # Databases
  should_install_app postgresql databases && install_linux_packages optional postgresql 2>/dev/null
  should_install_app redis databases && install_linux_packages optional redis 2>/dev/null
  should_install_app mysql databases && install_linux_packages optional mysql-server 2>/dev/null
  should_install_app pgadmin databases && install_pgadmin_linux
  should_install_app mongodb databases && install_mongodb_linux

  # Media
  should_install_app vlc media && install_linux_packages optional vlc 2>/dev/null

  # Utilities
  should_install_app screenshot-tool utilities && install_linux_packages optional flameshot 2>/dev/null
  should_install_app keyboard-viz utilities && install_linux_packages optional screenkey 2>/dev/null

  # Tentar instalar apps via Snap se disponÃ­vel
  if has_cmd snap; then
    msg "â–¶ Instalando apps selecionados via Snap"
    should_install_app slack productivity && ensure_snap_app slack "Slack" com.slack.Slack slack optional --classic
    should_install_app discord communication && ensure_snap_app discord "Discord" com.discordapp.Discord discord optional
    should_install_app spotify media && ensure_snap_app spotify "Spotify" com.spotify.Client spotify optional
    should_install_app obsidian productivity && ensure_snap_app obsidian "Obsidian" md.obsidian.Obsidian obsidian optional --classic
    should_install_app postman dev-tools && ensure_snap_app postman "Postman" com.getpostman.Postman postman optional
    should_install_app dbeaver dev-tools && ensure_snap_app dbeaver-ce "DBeaver" io.dbeaver.DBeaverCommunity dbeaver optional
    should_install_app notion productivity && ensure_snap_app notion-snap-reborn "Notion" "" notion optional
  fi

  # Tentar instalar apps via Flatpak se disponÃ­vel
  if has_cmd flatpak; then
    msg "â–¶ Instalando apps selecionados via Flatpak"
    should_install_app slack productivity && ensure_flatpak_app com.slack.Slack "Slack" slack slack optional
    should_install_app discord communication && ensure_flatpak_app com.discordapp.Discord "Discord" discord discord optional
    should_install_app spotify media && ensure_flatpak_app com.spotify.Client "Spotify" spotify spotify optional
    should_install_app obsidian productivity && ensure_flatpak_app md.obsidian.Obsidian "Obsidian" obsidian obsidian optional
    should_install_app postman dev-tools && ensure_flatpak_app com.getpostman.Postman "Postman" postman postman optional
    should_install_app dbeaver dev-tools && ensure_flatpak_app io.dbeaver.DBeaverCommunity "DBeaver" dbeaver-ce dbeaver optional
    should_install_app screenshot-tool utilities && ensure_flatpak_app org.flameshot.Flameshot "Flameshot" "" flameshot optional
    should_install_app vlc media && ensure_flatpak_app org.videolan.VLC "VLC" "" vlc optional
  fi

  ensure_ghostty_linux
  install_modern_cli_tools
}

brew_install_formula() {
  local formula="$1"
  local level="${2:-critical}"
  if brew list --formula "$formula" >/dev/null 2>&1; then
    if should_ensure_latest; then
      if brew outdated --formula "$formula" 2>/dev/null | grep -qx "$formula"; then
        if brew upgrade "$formula" >/dev/null 2>&1; then
          INSTALLED_PACKAGES+=("brew: $formula (upgrade)")
        else
          record_failure "$level" "Falha ao atualizar formula Homebrew: $formula"
        fi
      fi
    fi
    return
  fi
  if ! brew install "$formula"; then
    record_failure "$level" "Falha ao instalar formula Homebrew: $formula"
  else
    INSTALLED_PACKAGES+=("brew: $formula (install)")
  fi
}

brew_install_cask() {
  local cask="$1"
  local level="${2:-optional}"
  if brew list --cask "$cask" >/dev/null 2>&1; then
    if should_ensure_latest; then
      if brew outdated --cask "$cask" 2>/dev/null | grep -qx "$cask"; then
        if brew upgrade --cask "$cask" >/dev/null 2>&1; then
          INSTALLED_PACKAGES+=("brew cask: $cask (upgrade)")
        else
          record_failure "$level" "Falha ao atualizar cask Homebrew: $cask"
        fi
      fi
    fi
    return
  fi
  if ! brew install --cask "$cask"; then
    record_failure "$level" "Falha ao instalar cask Homebrew: $cask"
  else
    INSTALLED_PACKAGES+=("brew cask: $cask (install)")
  fi
}

install_macos_prereqs() {
  if ! has_cmd brew; then
    record_failure "critical" "Homebrew nÃ£o encontrado. Instale via https://brew.sh para configurar shells, terminais e CLI."
    # Mesmo sem brew, ainda tentamos instalar prompts/plugins e ferramentas via installers oficiais.
    install_modern_cli_tools
    return
  fi
  if should_ensure_latest; then
    msg "â–¶ Atualizando Homebrew (brew update)"
    if brew update >/dev/null 2>&1; then
      INSTALLED_MISC+=("brew: update")
    else
      warn "Falha ao rodar brew update"
    fi
  fi
  msg "â–¶ Verificando dependÃªncias macOS (Homebrew)"
  local formulae=(
    git
    tmux
    neovim
    starship
    mise
    ripgrep
    fzf
    fd
    bat
    eza
    zoxide
    direnv
    jq
    git-delta
    lazygit
    gh
  )
  if is_truthy "$INSTALL_ZSH"; then
    formulae+=(zsh)
  fi
  if is_truthy "$INSTALL_FISH"; then
    formulae+=(fish)
  fi
  local formula=""
  for formula in "${formulae[@]}"; do
    brew_install_formula "$formula"
  done

  # Sempre instalar Ghostty (terminal emulator)
  brew_install_cask ghostty critical

  # Navegadores (condicionais)
  should_install_app firefox browsers && brew_install_cask firefox optional
  should_install_app chrome browsers && brew_install_cask google-chrome optional
  should_install_app brave browsers && brew_install_cask brave-browser optional
  should_install_app zen browsers && brew_install_cask zen-browser optional
  should_install_app arc browsers && brew_install_cask arc optional

  # Bancos
  should_install_app pgadmin databases && brew_install_cask pgadmin4 optional
  should_install_app mongodb databases && brew_install_cask mongodb-compass optional

  # VS Code - condicional baseado na seleÃ§Ã£o do usuÃ¡rio
  should_install_app vscode dev-tools && install_vscode

  # Docker Desktop (GUI + engine) - condicional
  if should_install_app docker dev-tools; then
    brew_install_cask docker optional
  fi

  install_modern_cli_tools
}

winget_install() {
  local id="$1"
  local friendly="$2"
  local level="${3:-optional}"
  local result=""
  result="$(winget list --id "$id" 2>/dev/null || true)"
  if [[ "$result" == *"$id"* ]]; then
    if should_ensure_latest; then
      if winget upgrade --id "$id" -e --accept-package-agreements --accept-source-agreements >/dev/null 2>&1; then
        INSTALLED_PACKAGES+=("winget: $friendly ($id) (upgrade)")
      else
        record_failure "$level" "Falha ao atualizar via winget: $friendly ($id)"
      fi
    fi
    return 0
  fi
  if ! winget install --id "$id" -e --accept-package-agreements --accept-source-agreements >/dev/null 2>&1; then
    record_failure "$level" "Falha ao instalar via winget: $friendly ($id)"
    return 0
  fi
  INSTALLED_PACKAGES+=("winget: $friendly ($id) (install)")
}

choco_install() {
  local package="$1"
  local friendly="$2"
  local level="${3:-optional}"
  local result=""
  result="$(choco list --local-only "$package" 2>/dev/null || true)"
  if [[ "$result" == *"$package"* ]]; then
    if should_ensure_latest; then
      if choco upgrade -y "$package" >/dev/null 2>&1; then
        INSTALLED_PACKAGES+=("choco: $friendly ($package) (upgrade)")
      else
        record_failure "$level" "Falha ao atualizar via Chocolatey: $friendly ($package)"
      fi
    fi
    return 0
  fi
  if ! choco install -y "$package" >/dev/null 2>&1; then
    record_failure "$level" "Falha ao instalar via Chocolatey: $friendly ($package)"
    return 0
  fi
  INSTALLED_PACKAGES+=("choco: $friendly ($package) (install)")
}

install_windows_prereqs() {
  msg "â–¶ Verificando dependÃªncias Windows"
  if has_cmd winget; then
    if should_ensure_latest; then
      if winget source update --accept-source-agreements >/dev/null 2>&1; then
        INSTALLED_MISC+=("winget: source update")
      fi
    fi
    # Essenciais
    winget_install Git.Git "Git" critical
    winget_install Starship.Starship "Starship" critical
    winget_install JanDeDobbeleer.OhMyPosh "Oh My Posh" critical
    winget_install Neovim.Neovim "Neovim" critical
    winget_install Microsoft.WindowsTerminal "Windows Terminal" critical

    # Ferramentas CLI modernas
    winget_install jdx.mise "mise" critical
    winget_install BurntSushi.ripgrep "ripgrep" critical
    winget_install junegunn.fzf "fzf" critical
    winget_install sharkdp.fd "fd" critical
    winget_install sharkdp.bat "bat" critical
    winget_install ajeetdsouza.zoxide "zoxide" critical
    winget_install dandavison.delta "delta" critical
    winget_install jesseduffield.lazygit "lazygit" critical
    winget_install GitHub.cli "GitHub CLI" critical
    winget_install jqlang.jq "jq" critical
    winget_install direnv.direnv "direnv" critical
    winget_install eza-community.eza "eza" critical

    # Apps Cross-platform (equivalentes ao macOS Brewfile)
    msg "â–¶ Instalando apps selecionados via winget"

    # Browsers
    should_install_app firefox browsers && winget_install Mozilla.Firefox "Firefox"
    should_install_app chrome browsers && winget_install Google.Chrome "Google Chrome"
    should_install_app brave browsers && winget_install Brave.Brave "Brave"
    should_install_app arc browsers && winget_install TheBrowserCompany.Arc "Arc"

    # Development
    should_install_app vscode dev-tools && install_vscode
    should_install_app docker dev-tools && winget_install Docker.DockerDesktop "Docker Desktop"
    should_install_app postman dev-tools && winget_install Postman.Postman "Postman"
    should_install_app dbeaver dev-tools && winget_install dbeaver.dbeaver "DBeaver"
    should_install_app postgresql databases && winget_install PostgreSQL.PostgreSQL "PostgreSQL"
    should_install_app redis databases && winget_install Redis.Redis "Redis"
    should_install_app mysql databases && winget_install Oracle.MySQL "MySQL"
    should_install_app pgadmin databases && winget_install pgAdmin.pgAdmin4 "pgAdmin"
    should_install_app mongodb databases && winget_install MongoDB.Compass "MongoDB Compass"

    # Productivity
    should_install_app slack productivity && winget_install SlackTechnologies.Slack "Slack"
    should_install_app notion productivity && winget_install Notion.Notion "Notion"
    should_install_app obsidian productivity && winget_install Obsidian.Obsidian "Obsidian"

    # Communication
    should_install_app discord communication && winget_install Discord.Discord "Discord"

    # Media
    should_install_app vlc media && winget_install VideoLAN.VLC "VLC"
    should_install_app spotify media && winget_install Spotify.Spotify "Spotify"

    # Utilities
    winget_install Microsoft.PowerToys "PowerToys"  # PowerToys Ã© sempre Ãºtil no Windows
    should_install_app screenshot-tool utilities && winget_install ShareX.ShareX "ShareX"
    should_install_app keyboard-viz utilities && winget_install carnac.carnac "Carnac"
  elif has_cmd choco; then
    # Essenciais
    choco_install git "Git" critical
    choco_install starship "Starship" critical
    choco_install oh-my-posh "Oh My Posh" critical
    choco_install neovim "Neovim" critical
    choco_install microsoft-windows-terminal "Windows Terminal" critical

    # Ferramentas CLI modernas
    choco_install mise "mise" critical
    choco_install ripgrep "ripgrep" critical
    choco_install fzf "fzf" critical
    choco_install fd "fd" critical
    choco_install bat "bat" critical
    choco_install zoxide "zoxide" critical
    choco_install delta "delta" critical
    choco_install lazygit "lazygit" critical
    choco_install gh "GitHub CLI" critical
    choco_install jq "jq" critical
    choco_install direnv "direnv" critical
    choco_install eza "eza" critical

    # Apps Cross-platform via Chocolatey
    msg "â–¶ Instalando apps selecionados via Chocolatey"

    # Browsers
    should_install_app firefox browsers && choco_install firefox "Firefox"
    should_install_app chrome browsers && choco_install googlechrome "Google Chrome"
    should_install_app brave browsers && choco_install brave "Brave"

    # Development
    should_install_app vscode dev-tools && install_vscode
    should_install_app docker dev-tools && choco_install docker-desktop "Docker Desktop"
    should_install_app postman dev-tools && choco_install postman "Postman"
    should_install_app dbeaver dev-tools && choco_install dbeaver "DBeaver"
    should_install_app postgresql databases && choco_install postgresql "PostgreSQL"
    should_install_app redis databases && choco_install redis "Redis"
    should_install_app mysql databases && choco_install mysql "MySQL"
    should_install_app pgadmin databases && choco_install pgadmin4 "pgAdmin"
    should_install_app mongodb databases && choco_install mongodb "MongoDB"

    # Productivity
    should_install_app slack productivity && choco_install slack "Slack"
    should_install_app notion productivity && choco_install notion "Notion"
    should_install_app obsidian productivity && choco_install obsidian "Obsidian"

    # Communication
    should_install_app discord communication && choco_install discord "Discord"

    # Media
    should_install_app vlc media && choco_install vlc "VLC"
    should_install_app spotify media && choco_install spotify "Spotify"

    # Utilities
    choco_install powertoys "PowerToys"  # PowerToys Ã© sempre Ãºtil no Windows
    should_install_app screenshot-tool utilities && choco_install sharex "ShareX"
    should_install_app keyboard-viz utilities && choco_install carnac "Carnac"
  else
    warn "Nem winget nem Chocolatey foram encontrados. Instale um deles para que o script possa instalar shells/terminais automaticamente."
  fi
}

install_prerequisites() {
  case "$TARGET_OS" in
    linux|wsl2)
      install_linux_prereqs
      if is_wsl2; then
        msg "  â„¹ï¸  WSL2 detectado - usando configuraÃ§Ãµes Linux com ajustes para Windows"
      fi
      ;;
    macos) install_macos_prereqs ;;
    windows) install_windows_prereqs ;;
  esac

  # Instalar Brewfile (macOS) - apps adicionais
  install_brewfile

  # Instalar extensÃµes VS Code
  install_vscode_extensions
}
apply_shared_configs() {
  msg "â–¶ Copiando configs compartilhadas"
  if is_truthy "$INSTALL_FISH" && has_cmd fish; then
    copy_dir "$CONFIG_SHARED/fish" "$HOME/.config/fish"
    normalize_crlf_to_lf "$HOME/.config/fish/config.fish"
  else
    msg "  âš ï¸ Fish nÃ£o selecionado/encontrado, pulando config."
  fi

  if is_truthy "$INSTALL_ZSH" && has_cmd zsh; then
    copy_file "$CONFIG_SHARED/zsh/.zshrc" "$HOME/.zshrc"
    normalize_crlf_to_lf "$HOME/.zshrc"
    if [[ -d "$HOME/.oh-my-zsh/custom/themes/powerlevel10k" || -d "$HOME/.oh-my-zsh/themes/powerlevel10k" ]]; then
      copy_file "$CONFIG_SHARED/zsh/.p10k.zsh" "$HOME/.p10k.zsh"
    else
      msg "  âš ï¸ Powerlevel10k nÃ£o encontrado em ~/.oh-my-zsh, pulando .p10k.zsh."
    fi
  else
    msg "  âš ï¸ Zsh nÃ£o selecionado/encontrado, pulando .zshrc."
  fi

  if has_cmd starship; then
    # Validar starship.toml antes de copiar
    local starship_config="$CONFIG_SHARED/starship.toml"
    if [[ -f "$starship_config" ]]; then
      msg "  ðŸ” Validando starship.toml..."
      # Usa print-config pois nÃ£o abre editor e retorna erro se o TOML estiver invÃ¡lido
      if STARSHIP_CONFIG="$starship_config" starship print-config >/dev/null 2>&1; then
        msg "  âœ… starship.toml vÃ¡lido"
        copy_file "$starship_config" "$HOME/.config/starship.toml"
        local preset="${STARSHIP_PRESET:-$STARSHIP_PRESET_DEFAULT}"
        if [[ -n "$preset" ]]; then
          msg "  ðŸŽ¨ Aplicando preset Starship: $preset"
          if ! starship preset "$preset" -o "$HOME/.config/starship.toml" >/dev/null 2>&1; then
            record_failure "critical" "Falha ao aplicar preset Starship ($preset)"
          fi
        fi
      else
        warn "starship.toml invÃ¡lido ou com erros de sintaxe. Pulando..."
        msg "  ðŸ’¡ Execute 'STARSHIP_CONFIG=\"$starship_config\" starship print-config' para testar o arquivo manualmente"
      fi
    else
      warn "starship.toml nÃ£o encontrado em $starship_config"
    fi
  else
    msg "  âš ï¸ Starship nÃ£o encontrado, pulando starship.toml."
  fi

  if has_cmd git; then
    copy_file "$CONFIG_SHARED/git/.gitconfig" "$HOME/.gitconfig"
    copy_file "$CONFIG_SHARED/git/.gitconfig-personal" "$HOME/.gitconfig-personal"
    copy_file "$CONFIG_SHARED/git/.gitconfig-work" "$HOME/.gitconfig-work"
  else
    msg "  âš ï¸ Git nÃ£o encontrado, pulando .gitconfig."
  fi

  if has_cmd mise; then
    copy_dir "$CONFIG_SHARED/mise" "$HOME/.config/mise"
  else
    msg "  âš ï¸ Mise nÃ£o encontrado, pulando config."
  fi

  if has_cmd nvim; then
    copy_dir "$CONFIG_SHARED/nvim" "$HOME/.config/nvim"
  else
    msg "  âš ï¸ Neovim nÃ£o encontrado, pulando config."
  fi

  if has_cmd tmux; then
    copy_file "$CONFIG_SHARED/tmux/.tmux.conf" "$HOME/.tmux.conf"
  else
    msg "  âš ï¸ tmux nÃ£o encontrado, pulando .tmux.conf."
  fi

  copy_vscode_settings

  if [[ -d "$CONFIG_SHARED/.ssh" ]]; then
    copy_dir "$CONFIG_SHARED/.ssh" "$HOME/.ssh"
    set_ssh_permissions
  fi
}

get_git_value() {
  local file="$1"
  local key="$2"
  grep -m1 "$key" "$file" 2>/dev/null | awk -F'= ' '{print $2}'
}

configure_git_profiles() {
  [[ "$MODE" != "install" ]] && return
  if ! ask_yes_no "Configurar diretÃ³rios/identidades Git agora?"; then
    return
  fi

  local default_personal_dirs="$HOME/personal,$HOME/projects"
  local default_work_dirs="$HOME/work,$HOME/workspace,$HOME/humu"
  local personal_dirs work_dirs personal_name personal_email personal_gh work_name work_email work_gh

  personal_name="$(get_git_value "$CONFIG_SHARED/git/.gitconfig-personal" "name")"
  personal_email="$(get_git_value "$CONFIG_SHARED/git/.gitconfig-personal" "email")"
  personal_gh="$(get_git_value "$CONFIG_SHARED/git/.gitconfig-personal" "user")"
  work_name="$(get_git_value "$CONFIG_SHARED/git/.gitconfig-work" "name")"
  work_email="$(get_git_value "$CONFIG_SHARED/git/.gitconfig-work" "email")"
  work_gh="$(get_git_value "$CONFIG_SHARED/git/.gitconfig-work" "user")"

  read -r -p "Dirs pessoais (sep. por vÃ­rgula) [$default_personal_dirs]: " personal_dirs
  personal_dirs="${personal_dirs:-$default_personal_dirs}"
  read -r -p "Dirs trabalho (sep. por vÃ­rgula) [$default_work_dirs]: " work_dirs
  work_dirs="${work_dirs:-$default_work_dirs}"
  read -r -p "Nome pessoal [$personal_name]: " personal_name_in
  read -r -p "Email pessoal [$personal_email]: " personal_email_in
  read -r -p "GitHub user pessoal [$personal_gh]: " personal_gh_in
  read -r -p "Nome trabalho [$work_name]: " work_name_in
  read -r -p "Email trabalho [$work_email]: " work_email_in
  read -r -p "GitHub user trabalho [$work_gh]: " work_gh_in

  personal_name="${personal_name_in:-$personal_name}"
  personal_email="${personal_email_in:-$personal_email}"
  personal_gh="${personal_gh_in:-$personal_gh}"
  work_name="${work_name_in:-$work_name}"
  work_email="${work_email_in:-$work_email}"
  work_gh="${work_gh_in:-$work_gh}"

  cat > "$HOME/.gitconfig-personal" <<EOF
[github]
    user = ${personal_gh}

[user]
    name = ${personal_name}
    email = ${personal_email}
    useConfigOnly = true
EOF

  cat > "$HOME/.gitconfig-work" <<EOF
[github]
    user = ${work_gh}

[user]
    name = ${work_name}
    email = ${work_email}
    useConfigOnly = true
EOF

  {
    cat <<'EOF'
[color]
    status = auto
    branch = auto
    interactive = auto
    diff = auto

[alias]
    st = status
    co = checkout
    br = branch
    ci = commit
    lg = log --oneline --graph --all --decorate
    last = log -1 HEAD
    unstage = reset HEAD --
    undo = reset --soft HEAD~1

[core]
    editor = nvim
    pager = delta

[interactive]
    diffFilter = delta --color-only

[delta]
    navigate = true
    light = false
    side-by-side = true
    line-numbers = true

[merge]
    conflictstyle = diff3

[diff]
    colorMoved = default

[push]
    default = current
    autoSetupRemote = true

[pull]
    rebase = false

[init]
    defaultBranch = main

[credential]
    helper = manager-core
    helper = cache --timeout=3600
EOF
    IFS=',' read -r -a pdirs <<< "${personal_dirs// /}"
    for d in "${pdirs[@]}"; do
      [[ -z "$d" ]] && continue
      echo "[includeIf \"gitdir:${d%/}/\"]"
      echo "    path = ~/.gitconfig-personal"
      echo ""
    done
    IFS=',' read -r -a wdirs <<< "${work_dirs// /}"
    for d in "${wdirs[@]}"; do
      [[ -z "$d" ]] && continue
      echo "[includeIf \"gitdir:${d%/}/\"]"
      echo "    path = ~/.gitconfig-work"
      echo ""
    done
  } > "$HOME/.gitconfig"

  msg "  âœ… Git configurado com diretÃ³rios/p perfis personalizados."
}

copy_vscode_settings() {
  local settings_file="$CONFIG_SHARED/vscode/settings.json"
  [[ -f "$settings_file" ]] || return

  local dest=""
  case "$TARGET_OS" in
    macos)
      dest="$HOME/Library/Application Support/Code/User/settings.json"
      if [[ -d "$(dirname "$dest")" ]] || has_cmd code; then
        copy_file "$settings_file" "$dest"
      else
        msg "  âš ï¸ VS Code nÃ£o encontrado em macOS, pulando settings."
      fi
      ;;
    linux)
      dest="$HOME/.config/Code/User/settings.json"
      if [[ -d "$(dirname "$dest")" ]] || has_cmd code; then
        copy_file "$settings_file" "$dest"
      else
        msg "  âš ï¸ VS Code nÃ£o encontrado em Linux, pulando settings."
      fi
      ;;
    windows)
      local base="${APPDATA:-}"
      if [[ -z "$base" ]]; then
        base="$HOME/AppData/Roaming"
      fi
      if [[ -n "$base" ]]; then
        copy_file "$settings_file" "$base/Code/User/settings.json"
        if [[ -d "$base/Code - Insiders/User" ]]; then
          copy_file "$settings_file" "$base/Code - Insiders/User/settings.json"
        fi
      else
        msg "  âš ï¸ APPDATA nÃ£o definido, nÃ£o foi possÃ­vel instalar settings do VS Code."
      fi
      ;;
  esac
}

apply_linux_configs() {
  local source_dir="$CONFIG_LINUX"
  [[ -d "$source_dir" ]] || source_dir="$CONFIG_UNIX_LEGACY"
  [[ -d "$source_dir" ]] || return
  msg "â–¶ Copiando configs Linux"
  copy_dir "$source_dir/ghostty" "$HOME/.config/ghostty"
}

apply_macos_configs() {
  local source_dir="$CONFIG_MACOS"
  [[ -d "$source_dir" ]] || source_dir="$CONFIG_UNIX_LEGACY"
  [[ -d "$source_dir" ]] || return
  msg "â–¶ Copiando configs macOS"

  # Ghostty terminal
  copy_dir "$source_dir/ghostty" "$HOME/Library/Application Support/com.mitchellh.ghostty"

  # Rectangle window manager
  if [[ -f "$source_dir/rectangle/com.knollsoft.Rectangle.plist" ]]; then
    copy_file "$source_dir/rectangle/com.knollsoft.Rectangle.plist" "$HOME/Library/Preferences/com.knollsoft.Rectangle.plist"
    msg "  âœ… Rectangle configurado (reinicie o app para aplicar)"
  fi

  # Stats system monitor
  if [[ -f "$source_dir/stats/com.exelban.Stats.plist" ]]; then
    copy_file "$source_dir/stats/com.exelban.Stats.plist" "$HOME/Library/Preferences/com.exelban.Stats.plist"
    msg "  âœ… Stats configurado (reinicie o app para aplicar)"
  fi

  # KeyCastr (nota: configuraÃ§Ã£o manual necessÃ¡ria para permissÃµes)
  if [[ -f "$source_dir/keycastr/keycastr.json" ]]; then
    msg "  ðŸ“‹ KeyCastr: configuraÃ§Ã£o disponÃ­vel em $source_dir/keycastr/keycastr.json"
    msg "     Lembre-se de dar permissÃ£o de Acessibilidade nas PreferÃªncias do Sistema"
  fi
}

apply_windows_configs() {
  [[ -d "$CONFIG_WINDOWS" ]] || return
  msg "â–¶ Copiando configs Windows"
  copy_windows_terminal_settings
  copy_windows_powershell_profiles
}

copy_windows_terminal_settings() {
  local wt_settings="$CONFIG_WINDOWS/windows-terminal-settings.json"
  [[ -f "$wt_settings" ]] || return
  local base="${LOCALAPPDATA:-}"
  if [[ -z "$base" ]]; then
    base="$HOME/AppData/Local"
  fi
  if [[ -z "$base" ]]; then
    msg "  âš ï¸ LOCALAPPDATA nÃ£o definido; pulando Windows Terminal."
    return
  fi

  local stable="$base/Packages/Microsoft.WindowsTerminal_8wekyb3d8bbwe/LocalState/settings.json"
  local preview="$base/Packages/Microsoft.WindowsTerminalPreview_8wekyb3d8bbwe/LocalState/settings.json"
  local unpackaged="$base/Microsoft/Windows Terminal/settings.json"
  copy_file "$wt_settings" "$stable"
  if [[ -d "$(dirname "$preview")" ]]; then
    copy_file "$wt_settings" "$preview"
  fi
  if [[ -d "$(dirname "$unpackaged")" ]]; then
    copy_file "$wt_settings" "$unpackaged"
  fi
}

copy_windows_powershell_profiles() {
  local profile_src="$CONFIG_WINDOWS/powershell/profile.ps1"
  [[ -f "$profile_src" ]] || return

  local user_home="${USERPROFILE:-$HOME}"
  local docs="$user_home/Documents"
  if [[ ! -d "$docs" ]] && has_cmd powershell.exe; then
    local docs_win
    docs_win="$(powershell.exe -NoProfile -Command '[Environment]::GetFolderPath("MyDocuments")' 2>/dev/null | tr -d '\r' || true)"
    if [[ -n "$docs_win" ]]; then
      # Priorizar wslpath (WSL2) sobre cygpath (Cygwin/MSYS2)
      if has_cmd wslpath; then
        docs="$(wslpath -u "$docs_win" 2>/dev/null || echo "$docs")"
      elif has_cmd cygpath; then
        docs="$(cygpath -u "$docs_win" 2>/dev/null || echo "$docs")"
      fi
    fi
  fi

  copy_file "$profile_src" "$docs/PowerShell/Microsoft.PowerShell_profile.ps1"
  copy_file "$profile_src" "$docs/WindowsPowerShell/Microsoft.PowerShell_profile.ps1"
}

install_fonts() {
  [[ -d "$CONFIG_FONTS" ]] || return
  local dest=""
  case "$TARGET_OS" in
    linux) dest="$HOME/.local/share/fonts" ;;
    macos) dest="$HOME/Library/Fonts" ;;
    windows)
      local base="${LOCALAPPDATA:-}"
      if [[ -z "$base" ]]; then
        base="$HOME/AppData/Local"
      fi
      dest="$base/Microsoft/Windows/Fonts"
      ;;
  esac

  [[ -n "$dest" ]] || return
  msg "â–¶ Instalando fontes em: $dest"
  mkdir -p "$dest"

  # Copia apenas arquivos de fonte (evita copiar pastas/arquivos extras)
  if command -v find >/dev/null 2>&1; then
    while IFS= read -r -d '' f; do
      cp "$f" "$dest/" 2>/dev/null || true
    done < <(find "$CONFIG_FONTS" -type f \( -iname '*.ttf' -o -iname '*.otf' -o -iname '*.ttc' \) -print0)
  else
    # fallback
    copy_dir "$CONFIG_FONTS" "$dest"
  fi

  if [[ "$TARGET_OS" == "linux" || "$TARGET_OS" == "macos" ]]; then
    if command -v fc-cache >/dev/null 2>&1; then
      fc-cache -f "$dest" >/dev/null 2>&1 || true
    fi
  fi

  INSTALLED_MISC+=("fonts: $dest")

  # ObservaÃ§Ã£o Windows:
  # Copiar fontes para %LOCALAPPDATA%\Microsoft\Windows\Fonts costuma funcionar para instalaÃ§Ã£o por usuÃ¡rio,
  # mas alguns apps sÃ³ reconhecem apÃ³s logout/restart. Para instalaÃ§Ã£o global, Ã© necessÃ¡rio copiar para C:\Windows\Fonts com privilÃ©gios de admin.
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VS Code Extensions - Export/Import
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export_vscode_extensions() {
  if ! has_cmd code; then
    return
  fi

  local extensions_file="$CONFIG_SHARED/vscode/extensions.txt"
  msg "  ðŸ“¦ Exportando extensÃµes VS Code..."

  mkdir -p "$(dirname "$extensions_file")"
  code --list-extensions > "$extensions_file" 2>/dev/null || warn "Falha ao exportar extensÃµes VS Code"
}

install_vscode_extensions() {
  if ! has_cmd code; then
    return
  fi

  local extensions_file="$CONFIG_SHARED/vscode/extensions.txt"

  if [[ ! -f "$extensions_file" ]]; then
    return
  fi

  msg "â–¶ Instalando extensÃµes VS Code"

  local installed_count=0

  local installed_extensions
  installed_extensions="$(code --list-extensions 2>/dev/null | tr '[:upper:]' '[:lower:]')"

  while IFS= read -r extension; do
    # Pular linhas vazias e comentÃ¡rios
    [[ -z "$extension" ]] && continue
    [[ "$extension" =~ ^# ]] && continue

    # Verificar se jÃ¡ estÃ¡ instalado (case-insensitive)
    local ext_lower
    ext_lower="$(echo "$extension" | tr '[:upper:]' '[:lower:]')"

    if echo "$installed_extensions" | grep -qi "^${ext_lower}$"; then
      continue
    fi

    msg "  ðŸ”Œ Instalando: $extension"
    if ! code --install-extension "$extension" --force >/dev/null 2>&1; then
      warn "Falha ao instalar extensÃ£o: $extension"
    else
      installed_count=$((installed_count + 1))
    fi
  done < "$extensions_file"

  if [[ $installed_count -gt 0 ]]; then
    INSTALLED_MISC+=("vscode extensions: $installed_count")
  fi
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Brewfile (macOS) - Export/Import
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export_brewfile() {
  if [[ "$TARGET_OS" != "macos" ]] || ! has_cmd brew; then
    return
  fi

  local brewfile="$CONFIG_MACOS/Brewfile"
  msg "  ðŸº Exportando Brewfile..."

  mkdir -p "$(dirname "$brewfile")"
  brew bundle dump --describe --force --file="$brewfile" 2>/dev/null || warn "Falha ao exportar Brewfile"
}

install_brewfile() {
  if [[ "$TARGET_OS" != "macos" ]] || ! has_cmd brew; then
    return
  fi

  # Verificar se o usuÃ¡rio optou por instalar o Brewfile
  if [[ "$INSTALL_BREWFILE" != "true" ]]; then
    msg "  â­ï¸  Pulando instalaÃ§Ã£o do Brewfile (nÃ£o selecionado)"
    return
  fi

  local brewfile="$CONFIG_MACOS/Brewfile"

  if [[ ! -f "$brewfile" ]]; then
    return
  fi

  msg "â–¶ Instalando apps via Brewfile"

  if ! brew bundle install --file="$brewfile" 2>/dev/null; then
    warn "Alguns apps do Brewfile falharam. Execute 'brew bundle check --file=$brewfile' para detalhes."
  else
    INSTALLED_MISC+=("brew bundle: install")
  fi
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Export Configs
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export_configs() {
  msg ""
  msg "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
  msg "â•‘   Exportando configs do sistema      â•‘"
  msg "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  msg "Sistema -> RepositÃ³rio: $SCRIPT_DIR"

  # Exportar configs compartilhadas
  msg "â–¶ Exportando configs compartilhadas"

  if [[ -f "$HOME/.config/fish/config.fish" ]]; then
    export_file "$HOME/.config/fish/config.fish" "$CONFIG_SHARED/fish/config.fish"
    normalize_crlf_to_lf "$CONFIG_SHARED/fish/config.fish"
  fi

  if [[ -f "$HOME/.zshrc" ]]; then
    export_file "$HOME/.zshrc" "$CONFIG_SHARED/zsh/.zshrc"
    normalize_crlf_to_lf "$CONFIG_SHARED/zsh/.zshrc"
    if [[ -f "$HOME/.p10k.zsh" ]]; then
      export_file "$HOME/.p10k.zsh" "$CONFIG_SHARED/zsh/.p10k.zsh"
      normalize_crlf_to_lf "$CONFIG_SHARED/zsh/.p10k.zsh"
    fi
  fi

  if [[ -f "$HOME/.config/starship.toml" ]]; then
    export_file "$HOME/.config/starship.toml" "$CONFIG_SHARED/starship.toml"
  fi

  if [[ -f "$HOME/.gitconfig" ]]; then
    export_file "$HOME/.gitconfig" "$CONFIG_SHARED/git/.gitconfig"
    [[ -f "$HOME/.gitconfig-personal" ]] && export_file "$HOME/.gitconfig-personal" "$CONFIG_SHARED/git/.gitconfig-personal"
    [[ -f "$HOME/.gitconfig-work" ]] && export_file "$HOME/.gitconfig-work" "$CONFIG_SHARED/git/.gitconfig-work"
  fi

  if [[ -d "$HOME/.config/nvim" ]]; then
    export_dir "$HOME/.config/nvim" "$CONFIG_SHARED/nvim"
  fi

  if [[ -f "$HOME/.tmux.conf" ]]; then
    export_file "$HOME/.tmux.conf" "$CONFIG_SHARED/tmux/.tmux.conf"
  fi

  # Exportar VS Code settings e extensÃµes
  export_vscode_settings
  export_vscode_extensions

  # Exportar Brewfile (macOS)
  export_brewfile

  # Exportar configs especÃ­ficas do OS
  case "$TARGET_OS" in
    linux)
      msg "â–¶ Exportando configs Linux"
      if [[ -d "$HOME/.config/ghostty" ]]; then
        export_dir "$HOME/.config/ghostty" "$CONFIG_LINUX/ghostty"
      fi
      ;;
    macos)
      msg "â–¶ Exportando configs macOS"
      if [[ -d "$HOME/Library/Application Support/com.mitchellh.ghostty" ]]; then
        export_dir "$HOME/Library/Application Support/com.mitchellh.ghostty" "$CONFIG_MACOS/ghostty"
      fi
      ;;
    windows)
      msg "â–¶ Exportando configs Windows"
      export_windows_configs_back
      ;;
  esac

  msg ""
  msg "âœ… Configs exportadas com sucesso para: $SCRIPT_DIR"
  msg "ðŸ’¡ Execute 'git status' para ver as mudanÃ§as"
}

export_vscode_settings() {
  local src=""
  case "$TARGET_OS" in
    macos)
      src="$HOME/Library/Application Support/Code/User/settings.json"
      ;;
    linux)
      src="$HOME/.config/Code/User/settings.json"
      ;;
    windows)
      local base="${APPDATA:-$HOME/AppData/Roaming}"
      src="$base/Code/User/settings.json"
      ;;
  esac

  if [[ -f "$src" ]]; then
    export_file "$src" "$CONFIG_SHARED/vscode/settings.json"
  fi
}

export_windows_configs_back() {
  local base="${LOCALAPPDATA:-$HOME/AppData/Local}"

  # Windows Terminal settings
  local wt_stable="$base/Packages/Microsoft.WindowsTerminal_8wekyb3d8bbwe/LocalState/settings.json"
  if [[ -f "$wt_stable" ]]; then
    export_file "$wt_stable" "$CONFIG_WINDOWS/windows-terminal-settings.json"
  fi

  # PowerShell profile
  local ps_profile="${USERPROFILE:-$HOME}/Documents/PowerShell/Microsoft.PowerShell_profile.ps1"
  if [[ -f "$ps_profile" ]]; then
    export_file "$ps_profile" "$CONFIG_WINDOWS/powershell/profile.ps1"
  fi
}

show_usage() {
  cat <<EOF
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘   Dotfiles Manager - InstalaÃ§Ã£o e SincronizaÃ§Ã£o         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Uso: bash config/install.sh [COMANDO] [OPÃ‡Ã•ES]

COMANDOS:
  (nenhum)    Instala configs do repositÃ³rio -> sistema (padrÃ£o)
  export      Exporta configs do sistema -> repositÃ³rio
  sync        Sincroniza (exporta + instala)
  help        Mostra esta ajuda

EXEMPLOS:
  bash config/install.sh                  # Primeira instalaÃ§Ã£o
  bash config/install.sh export           # Salvar mudanÃ§as atuais
  bash config/install.sh sync             # Sincronizar bidirecional

NOTAS:
  â€¢ Backups automÃ¡ticos sÃ£o criados em ~/.dotfiles-backup-*
  â€¢ SeleÃ§Ã£o interativa de apps GUI (evita instalar tudo automaticamente)
  â€¢ Ferramentas modernas CLI (eza, bat, zoxide) sÃ£o instaladas automaticamente
  â€¢ Oh My Zsh e plugins sÃ£o configurados automaticamente
  â€¢ Fontes Nerd Fonts sÃ£o instaladas no local correto do sistema

EOF
}

main() {
  # Mostrar ajuda
  if [[ "$MODE" == "help" || "$MODE" == "--help" || "$MODE" == "-h" ]]; then
    show_usage
    exit 0
  fi

  # Validar que a pasta shared existe
  if [[ ! -d "$CONFIG_SHARED" ]]; then
    echo "âŒ Pasta shared/ nÃ£o encontrada em $CONFIG_SHARED" >&2
    exit 1
  fi

  TARGET_OS="$(detect_os)"

  # Modo EXPORT - Sistema -> RepositÃ³rio
  if [[ "$MODE" == "export" ]]; then
    export_configs
    exit 0
  fi

  # Modo SYNC - Exporta e depois instala
  if [[ "$MODE" == "sync" ]]; then
    export_configs
    msg ""
    msg "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    msg "â•‘   Agora instalando configs...        â•‘"
    msg "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    sleep 1
  fi

  # Modo INSTALL (padrÃ£o) - RepositÃ³rio -> Sistema
  msg "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
  msg "â•‘   Instalando configs do diretÃ³rio    â•‘"
  msg "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  msg "Origem: $SCRIPT_DIR"
  msg "Destino: $HOME"
  msg "Sistema: $TARGET_OS"

  # Criar backup se necessÃ¡rio
  if [[ -f "$HOME/.zshrc" ]] || [[ -d "$HOME/.config/fish" ]]; then
    msg "ðŸ“¦ Backup serÃ¡ criado em: $BACKUP_DIR"
  fi

  # Perguntar quais apps GUI o usuÃ¡rio deseja instalar
  ask_gui_apps

  # Escolher shells
  ask_shells

  # Escolher ferramentas opcionais (Atuin, spec-kit)
  ask_optional_tools

  # Perguntar quais runtimes o usuÃ¡rio deseja instalar globalmente (mise)
  ask_runtimes

  install_prerequisites

  apply_shared_configs
  configure_git_profiles

  case "$TARGET_OS" in
    linux|wsl2) apply_linux_configs ;;
    macos) apply_macos_configs ;;
    windows) apply_windows_configs ;;
  esac

  # Instalar runtimes selecionados apÃ³s prÃ©-requisitos + configs
  install_selected_runtimes

  install_fonts

  msg ""
  msg "âœ… ConfiguraÃ§Ãµes aplicadas com sucesso!"

  print_post_install_report

  if [[ -d "$BACKUP_DIR" ]]; then
    msg "ðŸ’¾ Backup das configs antigas: $BACKUP_DIR"
  fi

  msg ""
  msg "ðŸš€ PrÃ³ximos passos:"
  msg "   1. Reinicie seu terminal ou execute: exec \$SHELL"
  msg "   2. Configure git: git config --global user.name \"Seu Nome\""
  msg "   3. Configure git: git config --global user.email \"seu@email.com\""

  if has_cmd zsh; then
    msg "   4. Mude para Zsh: chsh -s \$(which zsh)"
  fi

  msg ""
  msg "ðŸ’¡ Dicas:"
  msg "   â€¢ Use 'bash config/install.sh export' para salvar mudanÃ§as"
  msg "   â€¢ Use 'bash config/install.sh sync' para sincronizar"

  print_final_summary
}

main "$@"
